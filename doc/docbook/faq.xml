<chapter><title>Frequently-Asked Questions</title>

<para>See the bugs section of this document for a list of known
bugs and solutions.</para>

<qandaset defaultlabel="qanda">

<qandaentry>
<question id='crazy'>
<para>Why all the craziness with custom serial cables?</para>
</question>
<answer>
<para>It was nothing more nor less than a form of customer
control. For a long time APC wanted to keep other people from talking
to its UPSes so it could lock out potential competition for its
PowerChute software.  Scrambling the leads on its serial cables was
a cheap way to accomplish this &mdash; in fact, they tended to be wired so
that if you tried a straight-through cable, opening a serial link to
the UPS would be interpreted as a shutdown command!</para>

<para>(Hardware companies often think like this &mdash; they lock up
interfaces by instinct, cornering a small market rather than growing a
bigger one.  It's fundamentally stupid and self-defeating, but it's
the kind of stupid that tends to sound good at an executive
meeting.)</para>

<para>Fortunately, APC has lost a lot of this attitude since about
2000; nowadays they even release technical information to the
<application>apcupsd</application> maintainers.</para>
</answer>
</qandaentry>

<qandaentry>
  <question>
    <para>What UPS brands does <application>apcupsd</application>
    support?</para>
  </question>
  <answer>
    <para>Currently <application>apcupsd</application> supports only
    APC UPSes. However, some companies such as Hewlett Packard put
    their own brand name on APC manufactured UPSes. Thus even if you
    do not have an APC branded UPS, it may work with
    <application>apcupsd</application>. You will need to know the
    corresponding APC model
    number. <application>apcupsd</application> supports all the
    popular APC models. See the installation and configurations
    sections of this document for more details.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>Does <application>apcupsd</application> support Windows?</para></question>
  <answer>
    <para>With release 3.8.0, <application>apcupsd</application> now
    runs on Win95/98, WinMe, WinNT, and Win2000 machines. All features of
    the Unix versions of <application>apcupsd</application> are
    implemented. The UPS EEPROM programming features of
    <application>apcupsd</application> have not been tested under
    Windows. Version 3.8.0 does not support simple signaling UPSes
    (BackUPS, etc). Version 3.8.1 does support most simple signaling
    UPSes, but not all cables (due to deficiencies in the Windows serial
    port API). Please note that we have had reports that
    <application>apcupsd</application> does not work properly on the WinXP
    system. If you have any information on this, please email us.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>I don't have a cable, which one should I build?</para></question>
  <answer>
    <para>First you must know if you have an apcsmart UPS or a
    voltage-signalling UPS &#x2014; See the <link
    linkend='type_table'>table of supported UPSes</link>. If you
    have a apcsmart UPS, we recommend building a <link
    linkend='custom_smart'>Custom Smart</link> cable. If you have a
    voltage-signaling UPS, we recommend that you build a <link
    linkend='custom_simple'>Custom Simple</link> cable.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>How much CPU resources does <application>apcupsd</application> use?</para></question>
  <answer>
    <para>Depending on your CPU speed, you may see more or less of
    the CPU consumed by <application>apcupsd</application>. On a
    400MHz Unix system, the CPU usage should fall well below
    0.1%. On slower systems, the percentage will increase
    proportionally to the decrease in the CPU speed. On a 400Mhz
    Win98 machine, the CPU usage will be on the order of
    0.5-1.0%. This is higher than for Unix systems. However,
    compared to the 30% CPU usage by APC's PowerChute (the version
    on the CDROM shipped with my UPS),
    <application>apcupsd</application>'s 0.5-1.0% is very
    modest.</para> <para>If you configure
    <application>apcupsd</application> to run with pthreads
    (<option>--with-pthreads</option> on the
    <command>./configure</command> line),
    <application>apcupsd</application> will run considerably faster,
    otherwise said, it will consume less of your CPU, and it will
    use approximately one third of the memory. For example, Carl
    Erhorn reports that on his Solaris system, &quot;With the old
    3-process version, we averaged about 4.8MB of total memory
    used. With the new single process, we use only about 1.7MB!
    That's also a very good improvement.&quot;</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>What language is <application>apcupsd</application> written in?</para></question>
  <answer>
    <para>It is written entirely in C.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>We are using apcupsd-3.8.1-1 in RedHat 6.2. The slave, when
  shutting down, is reporting an error at line 436 of apcupsd.c. The
  error is initiated by <command>apcupsd --killpower</command>! What
  can we do to fix this, and is it critical?</para></question>
  <answer>
    <para>No, the error is not serious. Unfortunately, the
    documentation in the area of master/slaves is not very detailed,
    and for that reason, your slave setup is not totally correct as
    explained below.</para>

    <para>On master machines, we modify
    <filename>/etc/rc.d/init.d/halt</filename> to re-invoke apcupsd
    with the <option>--killpower</option> option (actually the
    script apccontrol is called). This causes the UPS to send the
    codes to the UPS to make it power off.</para>

    <para>On slave machines, these modifications should not be made
    to the <filename>/etc/rc.d/init.d/halt</filename> script since
    the slave has no connection to the UPS.</para>

    <para>To eliminate the problem, on all your slave machines, either
    restore the original halt file, or simply delete all the lines
    containing ***apcupsd***, which were inserted by the apcupsd
    installation process.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>To test <application>apcupsd</application>, I unplugged the
  UPS to simulate a power outage. After the machine went into the
  shutdown process I plugged the UPS back into the commercial power
  source. This caused the shutdown process to hang after the daemon
  tried to shut-off the ups. Have you run into this problem, and if so
  do you have a remedy?</para></question>
  <answer>
    <para>Normally, once the shutdown process has begun, we cannot
    stop it, though there <emphasis>is</emphasis> some code that
    tries to do so, we don't consider it a very good idea &mdash;
    how do you stop a shutdown that has killed off half of the
    daemons running on your system? Most likely you will be left
    with an unusable system. In addition, when apcupsd is
    re-executed in the halt script after the disks are synced, it
    tries to shut off the UPS power, but the UPS will generally
    refuse to do so if the AC power is on. Since we cannot be 100%
    sure whether or not the UPS will shut off the power, we don't
    attempt to reboot the system if we detect that the power is back
    as it might then get caught by a delayed power off (at least for
    Smart UPSes).</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>After running apcupsd for a while, I get the following
  error: &quot;Serial communications with UPS lost.&quot; What is
  the problem?</para></question>
  <answer>
    <para>We use standard Unix serial port read() and write() calls
    so once a connection is made, we generally have few
    problems. However, there have been reports that APC's SNMP
    Management Card can cause serial port problems. If you have such
    a card, we suggest that you remove it and see if the problem
    goes away. It is also possible that some other process such as a
    <application>getty</application> is reading the serial
    port.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>When apcupsd starts, I get the following error:
  &quot;attach_shmarea: cannot get shm area: Identifier
  removed.&quot; What is the problem?</para></question>
  <answer>
    <para>This problem and the problem of <emphasis
    role="bold">cannot create shm area</emphasis> are due to the
    fact that the shared memory key that apcupsd wants to use is
    already in use. This happens most frequently when there is an
    old zombie apcupsd process still in the system.  The solution is
    to remove the old process.  You can often see what is going on
    by doing a: <command>ipcs</command> command as root when apcupsd
    is not running. If you see a segment with the key 0x10feed01,
    you can be sure there is some old apcupsd process still using
    it. If you cannot kill the old process, you can try using
    <command>ipcrm</command> (see the man pages).  Recent versions
    of <application>apcupsd</application> starting with
    apcupsd-3.8.2Beta6 should no longer have this problem as they
    will automatically try using a different key.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>I get the following error: &quot;Starting apcupsd power
  management.  Mar 20 21:19:40 box apcupsd[297]: apcupsd FATAL ERROR
  in apcserial.c at line 83. Cannot open UPS tty /dev/cua01: No such
  file or directory.&quot; What is the problem?</para></question>
  <answer>
    <para>The two most likely causes of your problem are:  1. You have the
    wrong serial port device name in the apcupsd.conf file.
    2. The device name is not defined on your system.
    Suggestions for proceeding:For the first item, check what your
    serial port device should be named. You might be able to find the
    name with an:</para>
<programlisting>
ls /dev
</programlisting>

    <para>Normally there will be hundreds or even thousands of names
    that print. If that doesn't produce anything useful, you can try
    step 2.  Perhaps your device is not defined. To get more
    information on your devices try man <command>MAKEDEV</command>
    or <command>find / -name MAKEDEV</command>.  It is often located
    in <command>/dev/MAKEDEV</command>.  Looking at the
    documentation may tell you what the correct name is, or at least
    allow you to create the device.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>How do I ensure that the slaves shutdown before the master?</para></question>
  <answer>
    <para>There are several strategies for getting the slaves
    properly shutdown before shutting down the master. The first is
    to make the master wait a period of time for the slaves to
    shutdown before doing its own shutdown. Currently, the master
    always waits 30 seconds before starting its own shutdown. If
    this is insufficient, you can add additional time by putting an
    appropriate <emphasis role="bold">sleep</emphasis> shell command
    in the <filename>/etc/apcupsd/apccontrol</filename> file just
    before the actual system shutdown command is executed (there are
    something like 3 places). The second strategy is to put a
    TIMEOUT value in the apcupsd.conf file on the slave that is
    sufficiently short that you are sure that the slave will
    shutdown before the master. If the shutdown is done with a
    poweroff, this will also save power so that the master can stay
    up longer.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>How do I ensure that my database server is correctly shutdown?</para></question>
  <answer>
    <para>You simply add whatever commands are necessary in the
    appropriate case statements in
    <filename>/etc/apcupsd/apccontrol</filename>, which is a
    standard script file that is called to actually do the
    shutdown. Alternatively, you can add your own script file that
    will be called before doing the commands in
    <application>apccontrol</application>. Your script file must
    have the same name as the appropriate case statement in
    <application>apccontrol</application>; it must be executable;
    and it must be in the same directory as
    <application>apccontrol</application>.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>I have Win2k Advanced server, and when starting the service,
    get: Could not start the Apcupsd Server service on Local Computer.
    Error 1067: The process terminated unexpectedly</para></question>
  <answer>
    <para>The most common error causing your problem is an incorrect
    serial port specification on your DEVICE directive. It should be:</para>
<programlisting>
DEVICE /dev/com2
</programlisting>
    <para>On WinNT machines, and probably Win2000 machines you MUST
    use <filename>/dev/com2</filename> unless you modify the
    behavior of the boot process to prevent Windows from probing the
    port. This is documented in our manual for WinNT. Although I
    imagine it is the same for Win2000, I am not sure.</para>

    <para>The second most common problem is bad placement of the
    files &#x2014; i.e. you did not install them in c:\apcupsd
    Unfortunately for the current release, this path is &quot;hard
    coded&quot; into the binaries.</para>

    <para>The third most common problem is that you did not run the
    <filename>setup.bat</filename> script after loading the
    files. This is necessary to install apcupsd as a service.</para>

    <para>If all the above fails, try starting apcupsd by hand
    inside a CYGWIN <application>rxvt</application> window &#x2014;
    if you use an rxvt window rather than a DOS window, you will see
    many more of the error messages.</para>

    <para>In addition, most of the apcupsd startup errors are
    reported in:
    <filename>c:\apcupsd\etc\apcupsd\apcupsd.events</filename></para>

    <para>Many error messages associated with Windows services will
    be reported in the Windows System Log.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question><para>When using USB, I get the following log messages: usb-uhci.c:
  interrupt, status 3, frame# 826. What does it mean?</para></question>
  <answer>
    <para>It means one transfer worked (bit 0 in status) and another
    one (after that) failed (bit 1) at time frame 826. This kind of
    soft error is common on USB and if everything seems to be
    working, you can ignore it.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question>
    <para><application>apcnisd</application> doesn't work. It always
    gives: FATAL ERROR in apcipc.c at line 497. attach_shmarea: shared
    memory version mismatch (or UPS not yet ready to report)</para>
  </question>
  <answer>
    <para>Unfortunately <application>apcnisd</application> does not
    work with pthreads enabled. You have the following options:</para>

   <orderedlist>
   <listitem>
     <para>If you build with pthreads enabled,
      <application>apcnisd</application> will not work no matter
      what you do.</para>
   </listitem>
   <listitem>
     <para>If you build with pthreads enabled, and you want
     to have network information from apcupsd, you must
     set NETSERVER ON. This is the configuration we
     recommend (i.e. using pthreads and NETSERVER ON).</para>
  </listitem>
  <listitem>
    <para>If you build with pthreads disabled, you have the choice
    of using <application>apcnisd</application> or the NETSERVER
    code. If you wish to use <application>apcnisd</application>, you
    must set NETSERVER OFF</para>
  </listitem>
  <listitem>
    <para>If you build with pthreads disabled, and you do not use
    <application>apcnisd</application>, you must set NETSERVER ON if
    you wish to have network information from apcupsd.</para>
  </listitem>
  </orderedlist>

  <para>Concerning the names one sees with &quot;ps&quot;.</para>

  <orderedlist>
  <listitem>
    <para>With pthreads enabled, on Linux machines, you will
    see multiple copies of apcupsd running, but they
    will all be called apcupsd rather than apcmain, 
    apcser, ... They will still run as LWP, but we
    are unable to set the names on threads (LWP). Note,
    though ps shows &quot;multiple copies&quot; of apcupsd running,
    it is really one memory image but with multiple threads.</para>
  </listitem>
  <listitem>
    <para>With pthreads disabled, we are able to set the
    child process names (at least on Linux) so you
    will see apcmain, apcser, apcnis, ... in the
    ps output. In this case, they are really different
    processes each with its own memory image (the
    code image is most likely shared).</para>
  </listitem>
  </orderedlist>
</answer>
</qandaentry>

<!-- prototype
<qandaentry>
<question>
<para></para>
</question>
<answer>
<para></para>
</answer>
</qandaentry>
-->

</qandaset>
</chapter>
