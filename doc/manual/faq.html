<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
    <title>FAQ</title>
   <meta name="Author" content="Kern Sibbald">
        <link rel=stylesheet href="apcupsd-styles.css" type="text/css">
</head>

<body>

<h2>Apcupsd Frequently Asked Questions</h2>
<DL>
 <DT>See <a href="bugs.html">the bugs section</a> of this document for
 a list of known bugs and solutions. </DT></dl>
<DL>
 <DT>What UPS brands does <b>apcupsd</b> support? </DT>
 <p>
 <dd>Currently <b>apcupsd</b> supports only APC UPSes. However,
some companies such as Hewlett Packard put their own brand name
on APC manufactured UPSes. Thus even if you do not have an APC
branded UPS, it may work with <b>apcupsd</b>. You will
need to know the corresponding APC model number. <b>apcupsd</b>
supports all the popular APC models.  See the installation and
configurations sections of this document for more details.
<p><p>
<dt>Does <b>apcupsd</b> support Windows?</dt><p></p>
<dd>With release 3.8.0, <b>apcupsd</b> now runs on Win95/98, WinMe,
WinNT, and Win2000 machines. All features of the Unix versions of <b>apcupsd</b>
are implemented. The UPS EEPROM programming features of <b>apcupsd</b>
have not been tested under Windows. Version 3.8.0 does not
support simple signaling UPSes (BackUPS, etc). Version 3.8.1 does
support most simple signaling UPSes, but not all cables (due to
deficiencies in the Windows serial port API). Please note that
we have had reports that <b>apcupsd</b> does not work properly
on the WinXP system. If you have any information on this,
please email us.
<p><p>
<dt>I don't have a cable, which one should I build?</dt>
<p><dd>First you must know if you have a Smart UPS or a
simple signaling UPS -- See the table of supported
UPSes in the <a href="configure.html">Configuration Chapter</a>
of this manual. If you have a Smart UPS (or a SubSmart), we recommend building
a <a href="cables.html">Smart-Custom Cable</a>. If you
have a Simple Signaling UPS, we recommend that you build
a <a href="cables.html">Simple-Custom Cable</a>.</dd>
<dt>How much CPU resources does <b>apcupsd</b> use?
<p><dd>
Depending on your CPU speed, you may see more or less of the
CPU consumed by <b>apcupsd</b>. On a 400MHz Unix system, the CPU
usage should fall well below 0.1%.  On slower systems, the percentage
will increase proportionally to the decrease in the CPU speed.
On a 400Mhz Win98 machine, the CPU usage will be on the order of
0.5-1.0%. This is higher than for Unix systems. However, 
compared to the 30% CPU usage by APC's PowerChute (the version
on the CDROM shipped with my UPS), <b>apcupsd's</b> 0.5-1.0% is very
modest.
<p>If you configure <b>apcupsd</b> to run with pthreads (--with-pthreads on the
./configure line), <b>apcupsd</b> will run considerably faster, otherwise said,
it will consume less of your CPU, and it will use approximately one third
of the memory. For example, Carl Erhorn reports that on his Solaris
system, &quot;With the old 3-process version, we averaged about 4.8MB of
total memory used. With the new single process, we use
only about 1.7MB! That's also a very good improvement.&quot;

</p>
<p><dt>
What language is <b>apcupsd</b> written in?
<p><dd>It is written entirely in C.
<p><p>
<dt>We are using apcupsd-3.8.1-1 in RedHat 6.2.
The slave, when shutting down, is reporting an error at line 436 of
apcupsd.c.
The error is initiated by apcupsd --killpower !
What can we do to fix this, and is it critical?
<p><dd>
    No, the error is not serious. Unfortunately, the documentation
    in the area of master/slaves is not very detailed, and for
    that reason, your slave setup is not totally correct as 
    explained below.
<p>
On master machines, we modify /etc/rc.d/init.d/halt to
re-invoke apcupsd with the --killpower option (actually
the script apccontrol is called).  This causes the UPS
to send the codes to the UPS to make it power off.
<p>
On slave machines, these modifications should not be
made to the /etc/rc.d/init.d/halt script since the
slave has no connection to the UPS.  
<p>To eliminate the problem, on all your slave machines, either
restore the original halt file, or simply delete all the
lines containing ***apcupsd***, which were inserted by 
the apcupsd installation process.</dd>
<dt>To test <b>apcupsd</b>, I unplugged the 
UPS to simulate a power outage.  After the machine went into the shutdown 
process I plugged the UPS back into the commercial power source.  This 
caused the shutdown process to hang after the daemon tried to shut-off the 
ups.  Have you run into this problem, and if so do you have a remedy?
</dt><p></p><dd>Normally, once the shutdown process has begun, 
we cannot stop it, though there IS some code that 
tries to do so, we don't consider it a very good idea -
how do you stop a shutdown that has killed off half
of the daemons running on your system?  Most likely
you will be left with an unusable system. In addition, 
when apcupsd is re-executed in the halt script
after the disks are synced, it tries to shut off the
UPS power, but the UPS will generally refuse to do so 
if the AC power is on.  Since we cannot be 100% sure
whether or not the UPS will shut off the power, we don't
attempt to reboot the system if we detect that the power
is back as it might then get caught by a delayed power
off (at least for Smart UPSes).
</dd>
<dt>After running apcupsd for a while, I get the following error:<br>
&quot;Serial communications with UPS lost.&quot; What is the problem?</dt>
<p></p>
<dd>We use standard Unix serial port read() and write() calls
so once a connection is made, we generally have few problems.
However, there have been reports that APC's SNMP 
Management Card can cause serial port problems. If you
have such a card, we suggest that you remove it and
see if the problem goes away. It is also possible that some
other process such as a <b>getty</b> is reading the serial
port.</dd>
<dt>When apcupsd starts, I get the following error:
&quot;attach_shmarea: cannot get shm area: Identifier removed.&quot; 
What is the problem?</dt>
<p></p>
<dd>This problem and the problem of <b>cannot create shm area</b> are
due to the fact that the shared memory key that apcupsd wants to use
is already in use. This happens most frequently when there is an old
zombie apcupsd process still in the system.<br>The solution is to 
remove the old process. <br>You can often see what is going on by
doing a: <b>ipcs</b> command as root when apcupsd is not running.
If you see a segment with the key 0x10feed01, you can be sure
there is some old apcupsd process still using it. If you cannot
kill the old process, you can try using <b>ipcrm</b> (see the
man pages).<br>Recent versions of apcupsd starting with 
apcupsd-3.8.2Beta6 should no longer have this problem as they
will automatically try using a different key.</dd>
<dt>I get the following error: &quot;Starting apcupsd power management.
Mar 20 21:19:40 box apcupsd[297]: apcupsd FATAL ERROR in apcserial.c at line 83.
Cannot open UPS tty /dev/cua01: No such file or directory.&quot;
What is the problem?</dt>
<p></p>
<dd>
The two most likely causes of your problem are:<p></p>

1. You have the wrong serial port device name
in the apcupsd.conf file.<br>
<p></p>
2. The device name is not defined on your system.<br>
<p></p>
Suggestions for proceeding:<p></p>

For the first item, check what your serial port 
device should be named. You might be able to find
the name with an:<br>
<p></p>
    ls /dev<br>
<p></p>

normally there will be hundreds or even thousands
of names that print.  <p></p>

If that doesn't produce anything useful, you can
try step 2.  Perhaps your device is not defined.
<p></p>
To get more information on your devices try:
<p>
    man MAKEDEV<br>
<p>

or
<p></p>
    find / -name MAKEDEV
<p></p>

it is often located in /dev/MAKEDEV<br>
Looking at the documentation may tell you
what the correct name is, or at least allow
you to create the device.

</dd>
<dt>How do I ensure that the slaves shutdown before the master?</dt>
<p></p>
  <dd>There are several strategies for getting the slaves
properly shutdown before shutting down the master.  The
first is to make the master wait a period of time for
the slaves to shutdown before doing its own shutdown.
Currently, the master always waits 30 seconds before
starting its own shutdown. If this is insufficient,
you can add additional time by putting an appropriate
<b>sleep</b> shell command in the /etc/apcupsd/apccontrol
file just before the actual system shutdown command
is executed (there are something like 3 places).
<p></p>
The second strategy is to put a TIMEOUT value in
the apcupsd.conf file on the slave that is sufficiently
short that you are sure that the slave will shutdown
before the master. If the shutdown is done with a
poweroff, this will also save power so that the master
can stay up longer.
 </dd>
<dt>How do I ensure that my database server is correctly shutdown?</dt>
<p></p>
<dd>You simply add whatever commands are necessary in the appropriate
case statements in <b>/etc/apcupsd/apccontrol</b>, which is a standard
script file that is called to actually do the shutdown. Alternatively,
you can add your own script file that will be called before doing
the commands in <b>apccontrol</b>. Your script file must have the
same name as the appropriate case statement in <b>apccontrol</b>; it
must be executable; and it must be in the same directory as
<b>apccontrol</b>.
</dd>
<dt>I have Win2k Advanced server, and when starting the
    service, get: Could not start the Apcupsd Server service on
    Local Computer. Error 1067: The process terminated  unexpectedly</dt>
    <dd>The most common error causing your problem is an
    incorrect serial port specification on your
    DEVICE directive.  It should be
<p>
DEVICE /dev/com2
<p>
On WinNT machines, and probably Win2000 machines
you MUST use /dev/com2 unless you modify the
behavior of the boot process to prevent Windows
from probing the port. This is documented in our
manual for WinNT. Although I imagine it is the
same for Win2000, I am not sure.
<p>
The second most common problem is bad placement
of the files -- i.e. you did not install them
in c:\apcupsd  Unfortunately for the current release,
this path is "hard coded" into the binaries.
<p>
The third most common problem is that you did not
run the setup.bat script after loading the files.
This is necessary to install apcupsd as a service.
<p>
If all the above fails, try starting apcupsd
by hand inside a CYGWIN rxvt window -- if you
use an rxvt window rather than a DOS window,
you will see many more of the error messages.
<p>
In addition, most
of the apcupsd startup errors are reported in:
<p>
c:\apcupsd\etc\apcupsd\apcupsd.events
<p>
many error messages associated with Windows
services will be reported in the Windows
System Log.
</dd>
<dt>When using USB, I get the following log messages:
usb-uhci.c: interrupt, status 3, frame# 826.  What does it
mean?</dt><dd>It means one transfer worked (bit 0 in status) and another
one ( after that) failed (bit 1) at timeframe 826.  This kind of soft
error is common on USB and if everything seems to be working, you can
ignore it.
</dd>

<dt>apcnisd doesn't work. It always gives: FATAL ERROR in apcipc.c at line 497.
 attach_shmarea: shared memory version mismatch (or UPS not yet ready to
 report)</dt><dd>
 Unfortunately apcnisd does not work with pthreads enabled. You have the
 following options:
<pre>
1. If you build with pthreads enabled, apcnisd will
   not work no matter what you do.

2. If you build with pthreads enabled, and you want
   to have network information from apcupsd, you must
   set NETSERVER ON. This is the configuration we
   recommend (i.e. using pthreads and NETSERVER ON).

3. If you build with pthreads disabled, you have the
   choice of using apcnisd or the NETSERVER code. If
   you wish to use apcnisd, you must set NETSERVER OFF
   
4. If you build with pthreads disabled, and you do
   not use apcnisd, you must set NETSERVER ON if you
   wish to have network information from apcupsd.

Concerning the names one sees with "ps".

1. With pthreads enabled, on Linux machines, you will
   see multiple copies of apcupsd running, but they
   will all be called apcupsd rather than apcmain, 
   apcser, ... They will still run as LWP, but we
   are unable to set the names on threads (LWP). Note,
   though ps shows "multiple copies" of apcupsd running,
   it is really one memory image but with multiple threads.

2. With pthreads disabled, we are able to set the
   child process names (at least on Linux) so you
   will see apcmain, apcser, apcnis, ... in the
   ps output. In this case, they are really different
   processes each with its own memory image (the
   code image is most likely shared).

</pre>
              

</dl>


</body>
</html>
